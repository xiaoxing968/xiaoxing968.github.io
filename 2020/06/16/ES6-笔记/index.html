<!DOCTYPE html><html lang="zh-CN" data-theme="left"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES6-笔记 | 肖大胖子</title><meta name="keywords" content="JavaScript"><meta name="author" content="Shaw"><meta name="copyright" content="Shaw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、let、const和var的作用和区别1.1 var 声明变量 ，声明的变量可以重复声明，同一作用域下，后声明的会覆盖前声明的， 有变量提升的特点  1.2 let 没有变量提升，必须先声明再使用，  同一作用域下不能重复声明同一个变量名，会报错。可以重新赋值。  let声明的变量产生一个块级作用域。  块级作用域：在js中成每个花括号之间的叫代码块 –{   代码块   }，{}的区域叫块级">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-笔记">
<meta property="og:url" content="http://example.com/2020/06/16/ES6-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="肖大胖子">
<meta property="og:description" content="1、let、const和var的作用和区别1.1 var 声明变量 ，声明的变量可以重复声明，同一作用域下，后声明的会覆盖前声明的， 有变量提升的特点  1.2 let 没有变量提升，必须先声明再使用，  同一作用域下不能重复声明同一个变量名，会报错。可以重新赋值。  let声明的变量产生一个块级作用域。  块级作用域：在js中成每个花括号之间的叫代码块 –{   代码块   }，{}的区域叫块级">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-06-15T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-19T16:00:00.000Z">
<meta property="article:author" content="Shaw">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/06/16/ES6-%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ES6-笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-01-20 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="肖大胖子" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">肖大胖子</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ES6-笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-15T16:00:00.000Z" title="发表于 2020-06-16 00:00:00">2020-06-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-19T16:00:00.000Z" title="更新于 2021-01-20 00:00:00">2021-01-20</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、let、const和var的作用和区别"><a href="#1、let、const和var的作用和区别" class="headerlink" title="1、let、const和var的作用和区别"></a>1、let、const和var的作用和区别</h2><h3 id="1-1-var"><a href="#1-1-var" class="headerlink" title="1.1 var"></a>1.1 var</h3><ul>
<li>声明变量 ，声明的变量可以重复声明，同一作用域下，后声明的会覆盖前声明的，</li>
<li>有变量提升的特点</li>
</ul>
<h3 id="1-2-let"><a href="#1-2-let" class="headerlink" title="1.2 let"></a>1.2 let</h3><ul>
<li><p>没有变量提升，必须先声明再使用，</p>
</li>
<li><p>同一作用域下不能重复声明同一个变量名，会报错。可以重新赋值。</p>
</li>
<li><p>let声明的变量产生一个块级作用域。</p>
<ul>
<li>块级作用域：在js中成每个花括号之间的叫代码块 –{   代码块   }，{}的区域叫块级作用域，在每一个{}内let声明出来的变量只能在这个{}中访问到。</li>
</ul>
</li>
<li><p><strong>暂时性死区</strong></p>
<ul>
<li>简而言之：在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</li>
<li>当程序的控制流程在新的作用域进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来。但因这时还未进行词法绑定，所以是不能访问的，如果访问就会报错。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//会报错，因为该代码块内有一个let，所以使该块区形成了一个封闭的作用域，a在使用let声明前不能被调用</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-const"><a href="#1-3-const" class="headerlink" title="1.3 const"></a>1.3 const</h3><ul>
<li>没有变量提升，必须声明在使用</li>
<li>用于声明常量，初始化时一定要赋值，声明之后不能再重复声明也不能再赋值。<ul>
<li>注意用const声明引用类型时（对象、数组）：对象和数组内部的项可以修改。也不能直接给对象、数组的变量名重新赋值  –不能 obj= 10</li>
</ul>
</li>
<li>会产生块级作用域，暂时性死区。</li>
</ul>
<h3 id="1-4-拓展"><a href="#1-4-拓展" class="headerlink" title="1.4 拓展"></a>1.4 拓展</h3><ul>
<li><p>局部作用域又叫（函数作用域），全局作用域和局部作用域都是相对函数内外而定义的。</p>
</li>
<li><p>console.time()   ……… console.timeEnd()可以控制台打印中间代码执行的时间。</p>
</li>
<li><p>循环变量时循环内部的处理函数，拿到的都是循环结束之后的最终变量值</p>
<ul>
<li>解决：<ul>
<li> 闭包：可以将闭包内部变量不会直接垃圾回收，而会存储在内存中，这样使用的时候就是上次存的变量值，而不是循环结束之后最终的变量值。</li>
<li> let：而let本身就  有块级作用域的特点，所以相当于闭包，在块级作用域使用的时候也会把值存到内存中。  </li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let的应用场景</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//打印5个5</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：若用var声明循环变量，还可用匿名函数自执行的方式解决</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    ;(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i) <span class="comment">// 0-4</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)<span class="comment">//将i值传到匿名函数中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、变量的解构赋值"><a href="#2、变量的解构赋值" class="headerlink" title="2、变量的解构赋值"></a>2、变量的解构赋值</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul>
<li>ES6 允许按照<strong>一定模式</strong>，从<strong>数组</strong>和<strong>对象</strong>中提取值，对变量进行赋值，这被称为解构—–要求*<strong>模式匹配</strong></li>
</ul>
<h3 id="1-2-数组解构赋值"><a href="#1-2-数组解构赋值" class="headerlink" title="1.2 数组解构赋值"></a>1.2 数组解构赋值</h3><p>有序— 按位置对应</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>完全解构：值与变量对应</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>不完全解构：值比变量多</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  --- a = <span class="number">1</span></span><br><span class="line"><span class="comment">//缺省</span></span><br><span class="line"><span class="keyword">let</span> [,,a]= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] --- a=<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>解构失败：变量比值多</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>] </span><br><span class="line">返回值：a=<span class="number">1</span>,b=undefind,c=undefind</span><br></pre></td></tr></table></figure></li>
<li><p><strong>拓展默认值</strong></p>
<ul>
<li>—解构失败的情况下，变量如果有默认值的情况下就显示默认值，有值的时候显示值</li>
<li>赋值为undefined时默认值生效，赋值为null时默认值不生效</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>]<span class="comment">// 返回 a=10,b=2,c=3；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>] <span class="comment">//返回a=10,b=20,c=30；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>] <span class="comment">//返回a=10,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>]=[<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>] <span class="comment">//返回a=10,b=null,c=null</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = []; <span class="comment">// x=1;y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>]; <span class="comment">//x=2;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>,<span class="number">2</span>]; <span class="comment">//x=1;y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];<span class="comment">//ReferenceError: y is not defined </span></span><br><span class="line"><span class="comment">//最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><p>数组的解构赋值，可以做数据交换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> ;</span><br><span class="line">[a,b] = [b ,a]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-对象解构赋值"><a href="#1-3-对象解构赋值" class="headerlink" title="1.3 对象解构赋值"></a>1.3 对象解构赋值</h3><p><strong>无序 – 匹配属性名</strong></p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>无序集合，必须按照属性 名匹配 ，所以解构中也没有缺省的情况。</li>
<li>完全解构，不完全解构、默认值和数组一样</li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p><strong>对象解构的作用</strong>：适用于取值，和函数的参数适用 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&quot;长沙&quot;</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125; = data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(username, age)  <span class="comment">//xiaoming 18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>报错的原因：JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JS将其解释为代码块，才能解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-拓展-函数参数的解构赋值"><a href="#1-4-拓展-函数参数的解构赋值" class="headerlink" title="1.4 拓展 函数参数的解构赋值"></a>1.4 拓展 函数参数的解构赋值</h3><ul>
<li><p>函数的参数也可以适用解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x,y]</span>)</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//传入参数的那一刻，数组参数就被解构成x和y。对于函数内部的代码来说，参数就是x和y</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>``两个反 引号，变量用${  变量  }包裹  ，</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>换行不需要使用换行符，可以直接写html结构，</li>
<li>不需要考虑单双引号嵌套问题</li>
<li>${}里面也可以自己写js语句；</li>
<li>方便简洁不容易出错</li>
</ul>
<h2 id="4、对象的扩展"><a href="#4、对象的扩展" class="headerlink" title="4、对象的扩展"></a>4、对象的扩展</h2><h3 id="4-1-对象的简写"><a href="#4-1-对象的简写" class="headerlink" title="4.1 对象的简写"></a>4.1 对象的简写</h3><h4 id="对象属性的简写"><a href="#对象属性的简写" class="headerlink" title="对象属性的简写"></a>对象属性的简写</h4><ul>
<li><p>属性名和属性值的变量名相同的情况下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    username,</span><br><span class="line">    age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象方法的简写"><a href="#对象方法的简写" class="headerlink" title="对象方法的简写"></a>对象方法的简写</h4><ul>
<li><p>省略冒号和function</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;红烧肉&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.eat()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><ul>
<li><p>一般情况下：[]使用的是变量，表达式，属性为数字时也使用[]</p>
</li>
<li><p>obj[]—[]里面放的是变量不是属性名，如果使用[]要获取属性名，[]里就要加字符串，也就是变量需要加引号，  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    [username]: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">    <span class="number">10</span>: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.username)  <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;username&#x27;</span>]) <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[username]) <span class="comment">//b</span></span><br><span class="line">obj[<span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>] = <span class="string">&quot;ab&quot;</span>; <span class="comment">//添加了一个属性名为ab的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;10: &quot;world&quot;, username: &quot;a&quot;, hello: &quot;b&quot;, ab: &quot;ab&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="number">10</span>])  <span class="comment">//world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-对象的方法"><a href="#4-2-对象的方法" class="headerlink" title="4.2 对象的方法"></a>4.2 对象的方法</h3><ul>
<li><p>数组的拼接：cancat()</p>
</li>
<li><p>对象拼接Object.assign(): 可以实现对象的浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是目标对象,从第二个参数开始就要拼接的对象</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(o1, o2, &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="number">30</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o1)<span class="comment">//&#123;a: 10, b: 20, c: 30&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Object.keys() 返回的是一个数组,数组里面是对象所有的属性名</p>
</li>
<li><p>Object.values() 返回的是一个数组,数组里面是对象所有的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(o)) <span class="comment">//[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(o))  <span class="comment">//[10, 20]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3-对象属性的设置"><a href="#4-3-对象属性的设置" class="headerlink" title="4.3 对象属性的设置"></a>4.3 对象属性的设置</h3><ul>
<li><p>获取对象中某个属性的描述对象；</p>
</li>
<li><p>设置对象中的某一个属性的特性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据劫持 vue</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对象中的某个属性的设置</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 值是否可以重写</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 是否可以循环遍历</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span> <span class="comment">// 是否可以重新修改属性的设置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、函数拓展"><a href="#5、函数拓展" class="headerlink" title="5、函数拓展"></a>5、函数拓展</h2><h3 id="5-1-函数默认值"><a href="#5-1-函数默认值" class="headerlink" title="5.1 函数默认值"></a>5.1 函数默认值</h3><ul>
<li><p>直接在形参上进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x = <span class="string">&quot;hello&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>特点</p>
<ul>
<li>不传实参，默认值生效</li>
<li>传递undefined，默认值生效</li>
<li>传递null，默认值不生效</li>
</ul>
</li>
<li><p>注意参数的位置</p>
<p>在参数传递过程中，要注意位置问题；</p>
<p>如果是最后一个参数的话，可以忽略不传递实参；</p>
<p>但是其他位置的话，要用undefined；</p>
<ul>
<li>解决方法1：有默认值的参数放到最后</li>
<li>解决方法2：形参和实参都以对象的形式（对象解构赋值）</li>
</ul>
</li>
</ul>
<h3 id="5-2-rest剩余参数"><a href="#5-2-rest剩余参数" class="headerlink" title="5.2 rest剩余参数"></a>5.2 rest剩余参数</h3><ul>
<li><p>语法：…变量名</p>
<ul>
<li>返回的是一个数组，接收的是没有形参接收的值</li>
<li>剩余参数必须写在形参的最后。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)  <span class="comment">//[3,4,5]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(rest))  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数*"></a>5.3 箭头函数*</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul>
<li><p>箭头左边（参数）</p>
<ul>
<li>一个参数的情况（）括号可以省略</li>
</ul>
</li>
<li><p>箭头右边（函数的执行代码）</p>
<ul>
<li>执行代码只有一句话的时候{}和return可以省略，但是对象要注意，加上（）避免代码歧义。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;<span class="comment">//不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><p>this指向的是定义<strong>this</strong>所在的对象，并且call、apply、bind是无法改变this的指向，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">f1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">//this</span></span><br><span class="line">obj.f1() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>



<ul>
<li>this是固定的=&gt;有利于封装回调函数；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将DOM事件的回调函数封装在一个对象里</span></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="params">event</span> =&gt;</span> <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用了箭头函数，导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数不能当做构造函数使用，不能使用<strong>new</strong>命令</p>
</li>
<li><p>箭头函数没有<strong>prototype</strong>显示原型；</p>
</li>
<li><p>箭头函数不能使用<strong>arguments</strong>，在遇到不定参的情况使用剩余参数代替（…变量名）；</p>
</li>
</ul>
<h4 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h4><ul>
<li><p>对象中方法的简写不要使用箭头函数</p>
</li>
<li><p>事件绑定函数，要谨慎使用箭头函数</p>
</li>
</ul>
<h3 id="5-4-严格模式"><a href="#5-4-严格模式" class="headerlink" title="5.4 严格模式"></a>5.4 严格模式</h3><ul>
<li><p>关键字   use strict ;    必须放在第一行</p>
</li>
<li><p>规则</p>
<ul>
<li> 变量先声明再使用</li>
<li>不允许指向全局对象，返回的是undefined</li>
<li>对arguments的限制：<ul>
<li>不允许重新赋值</li>
<li>不再追踪参数的变化</li>
<li>arguments.callee返回的是函数的本身，但是在严格模式下，不允许使用；</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arguments=10;</span></span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>对于只读属性重新赋值是会报错的</p>
</li>
</ul>
<h2 id="6、数组拓展"><a href="#6、数组拓展" class="headerlink" title="6、数组拓展"></a>6、数组拓展</h2><h3 id="6-1-拓展运算符…"><a href="#6-1-拓展运算符…" class="headerlink" title="6.1 拓展运算符…"></a>6.1 拓展运算符…</h3><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><ul>
<li><p>拓展运算符是三个点(…)</p>
</li>
<li><p>剩余参数的逆运用，将数组转换为参数序列</p>
</li>
</ul>
<h4 id="数组运用"><a href="#数组运用" class="headerlink" title="数组运用"></a>数组运用</h4><ul>
<li><p>数组去重</p>
</li>
<li><p>拉平多维数组(推荐使用flat())</p>
</li>
<li><p>实现浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉平多维数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> newArr = []</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    newArr.push(...item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr, arr2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象运用"><a href="#对象运用" class="headerlink" title="对象运用"></a>对象运用</h4><ul>
<li><p>对象浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟vuex</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapState = &#123;</span><br><span class="line"><span class="attr">userInfo</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">admin</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;guanliyuan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapMutations = &#123;</span><br><span class="line"><span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;xiaoming 正在跑&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;排骨&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm = &#123;</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    ...mapState <span class="comment">//浅拷贝mapState，这样在mapState中可以随需求添加数据</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    ...mapMutations</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(vm)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-数组方法的扩展"><a href="#6-2-数组方法的扩展" class="headerlink" title="6.2 数组方法的扩展"></a>6.2 数组方法的扩展</h3><ul>
<li><p>Array.of()  将参数内的数据转为数组，弥补new Array()的不足</p>
</li>
<li><p>find()和findIndex()</p>
<ul>
<li>find  返回符合条件的第一个成员</li>
<li>findIndex  返回符合条件的第一个成员的下标索引</li>
</ul>
</li>
<li><p>Includes()   判断是否含有某一个成员（在字符串中也可以使用）；返回的是一个布尔值；</p>
</li>
<li><p>Array.from()    伪数组转真数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">//(5) [empty × 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.of(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">//[5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.of(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">//[true]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> index = arr4.findIndex(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(index)  <span class="comment">//3  (第一个满足条件的下标是3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = arr4.find(<span class="function">(<span class="params">item, index, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span> </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//4  (第一个满足条件的是4)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr5.includes(<span class="string">&quot;hello&quot;</span>))   <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7、Symbol（）"><a href="#7、Symbol（）" class="headerlink" title="7、Symbol（）"></a>7、Symbol（）</h2><h3 id="7-1-概念和作用"><a href="#7-1-概念和作用" class="headerlink" title="7.1 概念和作用"></a>7.1 概念和作用</h3><ul>
<li><p>ES6新增了Symbol数据类型(是基础数据类型)，它用来<strong>生成一个独一无二的值</strong></p>
</li>
<li><p>Symbol数据常用来<strong>给对象属性赋值</strong>，让对象属性具备唯一性，不容易被覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obj&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="comment">//因为obj中属性名a冲突了，所以打印出来的结果会是</span></span><br><span class="line"><span class="comment">//  obj&#123; a: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因此，为了避免这种情况，可以用symbol当作属性名</span></span><br><span class="line"></span><br><span class="line">obj&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]:<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注：括号内可以加字符串，但只是对该Symbol进行解释说明（字符串相同时，两个symbol也不相等）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1, s2)  <span class="comment">//Symbol(s1) Symbol(s2)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.description)  <span class="comment">//s1</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&quot;s3&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">10</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>()]: <span class="number">20</span>,</span><br><span class="line">    [s3]: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//&#123;Symbol(): 10, Symbol(): 20, Symbol(s3): 30&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>以 Symbol 值作为键名，不会被常规方法遍历得到（见7.3拓展）。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
</li>
</ul>
<h4 id="实例-消除魔术字符串"><a href="#实例-消除魔术字符串" class="headerlink" title="实例: 消除魔术字符串"></a>实例: 消除魔术字符串</h4><ul>
<li><p>魔术字符串  在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">&#x27;Triangle&#x27;</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
</li>
<li><p>用Symbol值解决</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">triangle</span>: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">shape, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">Symbol</span>():</span><br><span class="line">      area = <span class="number">.5</span> * options.width * options.height;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="built_in">Symbol</span>(), &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-Symbol的方法"><a href="#7-2-Symbol的方法" class="headerlink" title="7.2 Symbol的方法"></a>7.2 Symbol的方法</h3><h4 id="s-description"><a href="#s-description" class="headerlink" title="s.description"></a>s.description</h4><p>获取Symbol()字符串的值</p>
<h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h4><ul>
<li><p>Symbol.for(‘’)  搜索是否有以该参数为名称的Symbol值</p>
<ul>
<li>有则返回这个Symbol值，否则新建一个以该字符串为名称的Symbol值，并将其注册到全局</li>
<li>如果里面的字符串的内容相同，Symbol也是相同</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;s1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s4&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s2)  <span class="comment">//Symbol(s1)</span></span><br><span class="line"><span class="built_in">console</span>.log(s3)  <span class="comment">//Symbol(s4)</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)    <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，</p>
<ul>
<li>前者会被登记在全局环境中供搜索，后者不会</li>
<li><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值</li>
<li>比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h4><ul>
<li><p>返回一个已登记的 Symbol 类型值的key</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//s2属于未登记的Symbol值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-拓展-属性名的遍历"><a href="#7-3-拓展-属性名的遍历" class="headerlink" title="7.3 拓展 属性名的遍历"></a>7.3 拓展 属性名的遍历</h3><ul>
<li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//无输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//a  b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols)<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br><span class="line"><span class="keyword">const</span> objNames = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objNames)  <span class="comment">//[]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8、set和map"><a href="#8、set和map" class="headerlink" title="8、set和map"></a>8、set和map</h2><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul>
<li><p>Set()本身是一个构造函数，用来实例化Set数据类型（类似于数组的数据结构，特点：不允许有重复项。</p>
</li>
<li><p>set实例的操作方法—用来操作数据</p>
<p>let s = new Set（）；</p>
<ul>
<li><p>s.size : 返回长度</p>
</li>
<li><p>s.add()  : 添加某个值，返回set结构本身</p>
</li>
<li><p>s.delete() : 删除值，删除成功返回true，否则返回false</p>
</li>
<li><p>s.has() ： 判断是否是set的成员，返回布尔值</p>
</li>
<li><p>s.clear() : 清除所有的成员，没有返回值。</p>
</li>
</ul>
</li>
<li><p>set实例的遍历方法—-遍历成员</p>
</li>
</ul>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul>
<li><p>Map对象保存键值对。是类似对象的数据解构。任何值(对象或者原始值) 都可以作为一个键或一个值</p>
</li>
<li><p>常用方法：</p>
<ul>
<li>m.size 成员的个数</li>
<li>m.set([1, 2, 3], “content3”)  添加一个内容</li>
<li>m.get(属性) 获取对应的值</li>
<li>m.has(属性) 判断属性是否存在</li>
<li>m.delete(属性) 删除属性</li>
<li>m.clear()  删除所有的属性</li>
</ul>
</li>
<li><p>Map和Object的区别</p>
<ul>
<li>一个Object 的键只能是字符串或者 Symbols，但一个Map 的键可以是任意值。</li>
<li>Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
</li>
</ul>
<h2 id="9、promise"><a href="#9、promise" class="headerlink" title="9、promise"></a>9、promise</h2><h3 id="9-1-promise概念，then、catch方法"><a href="#9-1-promise概念，then、catch方法" class="headerlink" title="9.1 promise概念，then、catch方法"></a>9.1 promise概念，then、catch方法</h3><ul>
<li><p>概念和理解：</p>
<ul>
<li>是ES6<strong>解决异步回调问题</strong>的一种解决方案</li>
</ul>
<p>由于js是单线程，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂，也叫做回调地狱；</p>
<ul>
<li>Promise对象可以理解为一次执行的异步操作，使用Promise对象之后，使用一种链式调用的方式来组织代码，让程序更具备可读性，可维护性</li>
</ul>
<p>=&gt;可以<strong>将异步操作以同步的操作的流程表达出来</strong>，避免了层层嵌套的回调函数</p>
<ul>
<li>promise和回调函数一样，都是要<strong>解决数据的传递和消息发送问题</strong>，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。</li>
</ul>
</li>
<li><p>语法：</p>
<p>promise是一个构造函数，使用时一般都需要new 一个实例对象。</p>
<p>接受一个函数作为参数，函数中也有两个参数（resolve，reject），resolve将异步操作成功状态下的结果返回。reject将异步操作失败状态写的结果返回。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(ture)&#123;</span><br><span class="line">               resolve(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               reject(<span class="string">&#x27;失败&#x27;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);<span class="comment">//p就是实例化的promise对象</span></span><br></pre></td></tr></table></figure>



<ul>
<li>then方法：接受两个回调函数作为参数，第一个回调函数是promise状态为resolve状态下调用，第二个时reject状态下调用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//第一个回调函数res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="comment">//第二个回调函数，res是个参数,接收resolve括号里返回的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>catch方法：promise失败状态调用。 同时也可以捕获到一些编写错误的代码，让错误以字符串的形式体现，不报错影响后续代码执行。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-2-Promise特点"><a href="#9-2-Promise特点" class="headerlink" title="9.2 Promise特点"></a>9.2 Promise特点</h3><ul>
<li><p>对象的状态不受外界影响</p>
<ul>
<li><p>三 个状态：进行中pending，已成功fulfilled，已失败rejected</p>
<p>pending表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；</p>
<p>这里的成功和失败都是逻辑意义上的；并非是要报错</p>
</li>
<li><p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p>
</li>
<li><p>一旦创建就会立即执行 ，处于进行中，内部直接执行的为同步，</p>
</li>
<li><p>resolve，reject—进行中转为了成功或失败，再使用then方法调用的是属于异步。   </p>
</li>
<li><p>没有调用resolve，reject时处理进行中状态，进行中下没有状态返回。</p>
</li>
</ul>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>
<ul>
<li>Promise状态改变只有两种可能:  pending =&gt;fulfilled    pending=&gt;rejected</li>
<li>一旦这两种情况发生，状态就凝固了，会一直保持这个结果，如果改变已经发生，再对Promise对象添加回调函数，也会立即得到这个结果</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)<span class="comment">//此时没有结果，因为p1没有resolve或者reject调用此时是进行中的状态，没有返回值，所有p2返会p1时也没有东西。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Promise里面同步和异步的判定</p>
<ul>
<li>里面是一个同步任务(状态为pending)</li>
<li>调用resolve/reject方法，状态就会发生改变</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise&quot;</span>) <span class="comment">//同步任务  =&gt; 进行中</span></span><br><span class="line">    resolve(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 异步任务 （微任务）</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出顺序  1   promise  2  123  成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-3-promise的链式操作"><a href="#9-3-promise的链式操作" class="headerlink" title="9.3 promise的链式操作"></a>9.3 promise的链式操作</h3><ul>
<li>必须在前一个then有return返回值，如果return是一个Promise对象，then 就接收的是promise对象中成功状态下的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             resolve(n)</span><br><span class="line">         &#125;, <span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fn(<span class="number">5</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line">     <span class="keyword">return</span> fn(++res)</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-4-Promise-all-和Promise-race"><a href="#9-4-Promise-all-和Promise-race" class="headerlink" title="9.4 Promise.all()和Promise.race()"></a>9.4 Promise.all()和Promise.race()</h3><ul>
<li> Promise.all()  处理并发 ，所有值就一起返回</li>
<li>Promise.race()  返回请求完成最快的—–(一般用于设置请求超时提示）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个请求如果超过500ms，返回请求超时提示信息</span></span><br><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;我是正确的请求&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">300</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>错误信息的处理<ul>
<li>直接在promise.all().catch(),只能返回错误信息，其他正确的信息无法返回。</li>
<li>谁报错谁自己处理，其他信息可以正确返回。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">3500</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&quot;p3&quot;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求所有的值是一起返回的</span></span><br><span class="line">        <span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br></pre></td></tr></table></figure>

<h2 id="10、iterator和for…of循环"><a href="#10、iterator和for…of循环" class="headerlink" title="10、iterator和for…of循环"></a>10、iterator和for…of循环</h2><h3 id="10-1-概念和作用"><a href="#10-1-概念和作用" class="headerlink" title="10.1 概念和作用"></a>10.1 概念和作用</h3><ul>
<li>概念：</li>
</ul>
<p>在集合的数据结构中，数组，对象，set，map 需要统一接口，来进行处理。Iterator就是这个机制，为不同的数据结构提供统一的接口，任何的数据结构，只要部署了iterator就可以进行循环遍历。</p>
<ul>
<li><strong>作用</strong><ul>
<li>1.为各种数据结构提供统一的、简便的访问接口，</li>
<li>2.使数据结构的成员能够按某种次序排列，</li>
<li>3.为for…of…提供消费</li>
</ul>
</li>
<li>Iterator的原理<ul>
<li>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li>
<li>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li>
<li>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li>
</ul>
</li>
</ul>
<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束，值为true的时候表示遍历结束</p>
<ul>
<li><p>模拟Iterator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIterator</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; arr.length?&#123;</span><br><span class="line">                <span class="attr">value</span>:arr[index++],<span class="comment">//因为闭包了，所以index++会储存在这个函数的作用域中</span></span><br><span class="line">                <span class="attr">done</span>:<span class="literal">false</span></span><br><span class="line">            &#125;:&#123;</span><br><span class="line">                <span class="attr">value</span>:<span class="literal">undefined</span>,</span><br><span class="line">                <span class="attr">done</span>:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr_iter = myIterator(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-2-部署Iterator接口"><a href="#10-2-部署Iterator接口" class="headerlink" title="10.2 部署Iterator接口"></a>10.2 部署Iterator接口</h3><ul>
<li><p><strong>Symbol.iterator属性(默认Iterator接口)</strong></p>
<p>在数据结构上部署iterator接口表现形式为，<strong>给对象或数组等集合增加</strong>Symbol.iterator<strong>属性</strong>，属性的内容是一个根据iterator接口规范自行实现的方法</p>
<p>=&gt; 一个数据结构只要有了Symbol.iterator属性，即是“可遍历的”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr_iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:28 &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr_iter.next())   <span class="comment">//review.html:29 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>原生具备Iterator接口的数据结构</p>
<p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p>
<p>调用这个属性，就能得到遍历器对象</p>
</li>
<li><p>对象部署Iterator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">next</span>: <span class="function">() =&gt;</span>&#123; <span class="comment">//如果是用function()则this输出的是next方法</span></span><br><span class="line">            <span class="comment">// console.log(this); //对象本身</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)) //对象的所有属性 =&gt; 数组</span></span><br><span class="line">            <span class="comment">// console.log(Object.keys(this)[index]) // 获取数组中对应索引下标的值</span></span><br><span class="line">            <span class="comment">// console.log(obj[Object.keys(this)[index]]) //获取对应的属性名的值 </span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).length)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[<span class="built_in">Object</span>.keys(<span class="built_in">this</span>)[index++]],</span><br><span class="line">                <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">                <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> y = obj[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br><span class="line"><span class="built_in">console</span>.log(y.next())</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-3-for…in-和-for…of循环"><a href="#10-3-for…in-和-for…of循环" class="headerlink" title="10.3 for…in 和 for…of循环"></a>10.3 for…in 和 for…of循环</h3><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul>
<li><p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for…of循环遍历它的成员。</p>
</li>
<li><p>也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p>
</li>
</ul>
<h4 id="for…of-和-for…in的区别"><a href="#for…of-和-for…in的区别" class="headerlink" title="for…of  和  for…in的区别"></a>for…of  和  for…in的区别</h4><ul>
<li><p>for…in</p>
<ul>
<li>返回的是<strong>索引值</strong>，是以字符串的形式</li>
<li> 不一定是按照一定的顺序返回的</li>
<li>不仅可以遍历本身的方法和属性，还可以遍历原型上的方法和属性</li>
</ul>
</li>
<li><p>for…of</p>
<ul>
<li>返回的是<strong>值</strong></li>
<li>是按照一定的顺序进行遍历</li>
<li>只能遍历本身的属性和方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">100</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.str = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)  <span class="comment">//name age sayHello str</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot; </span></span><br><span class="line">  <span class="comment">//for...of方法不会返回arr的foo属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11、generator"><a href="#11、generator" class="headerlink" title="11、generator"></a>11、generator</h2><h3 id="11-1-概念和语法"><a href="#11-1-概念和语法" class="headerlink" title="11.1 概念和语法"></a>11.1 概念和语法</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>语法上，首先可以把它理解成，Generator 函数是一个<strong>状态机</strong>，封装了多个内部状态。</li>
<li>执行Generator函数会<strong>返回一个遍历器对象</strong> =&gt; 是个遍历器对象生成函数。<br>返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态</li>
<li>形式上：Generator是一个普通函数</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p>function关键字与函数名之间有一个星号；</p>
</li>
<li><p>函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure></li>
<li><p>调用该函数返回的是一个遍历器对象(指针指向内部对象)，必须调用遍历器对象的next的方法，指针才能移向下一个对象；<br>每调用一次next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式(或return语句）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> f_i = fn();</span><br><span class="line">    <span class="built_in">console</span>.log((f_i).next())  <span class="comment">// a  b   &#123;value:&quot;hello&quot;,done:false&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-2-Yield表达式"><a href="#11-2-Yield表达式" class="headerlink" title="11.2 Yield表达式"></a>11.2 Yield表达式</h3><ul>
<li><p><strong>暂停执行函数的关键字</strong></p>
<p>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。</p>
<p>yield表达式就是暂停标志。</p>
</li>
<li><p>运行逻辑（案例详见11.3的拓展题）</p>
<ul>
<li>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li>
<li>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到return语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>（4）如果该函数没有<code>return</code>语句，则返回的对象的value属性值为undefined。</li>
</ul>
<p>不用yield表达式时，就变成了一个单纯的暂缓执行函数(调用next方法才能执行)</p>
</li>
</ul>
<h3 id="11-3-next方法的参数"><a href="#11-3-next方法的参数" class="headerlink" title="11.3 next方法的参数"></a>11.3 next方法的参数</h3><ul>
<li><p>yield表达式本身没有返回值，或者说总是返回undefined</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(fn_i.next());  <span class="comment">//&#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>next方法可以带一个参数，该参数就会被当作<strong>上一个yield表达式的返回值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f_i = fn();</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next())  <span class="comment">//&#123;value: &quot;hello&quot;, done: false&#125;</span></span><br><span class="line">f_i.next(<span class="number">10</span>)   <span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>拓展题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;							<span class="comment">//行1</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">20</span> / (<span class="keyword">yield</span> x + <span class="number">100</span>)			<span class="comment">//行2</span></span><br><span class="line">        <span class="built_in">console</span>.log(y)  <span class="comment">//5					//行3</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">2</span>						<span class="comment">//行4</span></span><br><span class="line">        <span class="built_in">console</span>.log(z)  <span class="comment">//6					//行5</span></span><br><span class="line">    <span class="keyword">return</span> x + y + z						<span class="comment">//行6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f_i = fn1(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f_i.next());  <span class="comment">//&#123;value: 105, done: false&#125;  </span></span><br><span class="line"><span class="comment">//第一次调用next，返回第一个yield（行2）后面的表达式结果(一个遍历器对象)  &#123;value: 5+100, done: false&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">4</span>));  <span class="comment">//&#123;value: 2.5, done: false&#125; </span></span><br><span class="line"><span class="comment">//第二次调用next，继续执行行3，此时由于next的参数4传给了上一个yield表达式(行2)的返回值，因此 y = 20 / 4 = 5。而console.log(f_i.next(4))打印的是行4中yield的返回值  &#123;value: 5/2, done: false&#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f_i.next(<span class="number">6</span>)); <span class="comment">//&#123;value: 16, done: true&#125;  </span></span><br><span class="line"><span class="comment">//第三次调用next，同理继续执行 行5，此时由于next的参数是6，传给了行4中yield后的返回值，因此 z = 6；而console.log(f_i.next(6))打印的是最后return的遍历器对象 value = x+y+z = 5+5+6 = 16</span></span><br></pre></td></tr></table></figure></li>
<li><p>作用：可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
</li>
</ul>
<h2 id="12、async函数-async…await"><a href="#12、async函数-async…await" class="headerlink" title="12、async函数  async…await"></a>12、async函数  async…await</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><ul>
<li>async函数是 Generator 函数的语法糖</li>
<li>将generator函数的*换成了<code> async</code>，将<code>yield</code> 替换成  <code>await</code></li>
<li>async函数返回的是一个Promise对象,可以 使用promise对象的方法。可以看作多个异步操作，包装成的一个 Promise 对象</li>
</ul>
<h3 id="12-2-基本用法"><a href="#12-2-基本用法" class="headerlink" title="12.2 基本用法"></a>12.2 基本用法</h3><ul>
<li><p>async函数返回的是一个Promise对象,可以 使用promise对象的方法</p>
<ul>
<li>使用then方法添加回调函数获取return后面的值</li>
<li>使用catch 来捕获错误信息</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());  <span class="comment">//Promise &#123;&lt;resolved&gt;: &quot;hello&quot;&#125;  //返回的是一个Promise对象</span></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">//&quot;hellp&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获错误信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.run()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)<span class="comment">//TypeError: obj.run is not a function</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="await-方法：一般情况下是结合promise对象使用。"><a href="#await-方法：一般情况下是结合promise对象使用。" class="headerlink" title="await()方法：一般情况下是结合promise对象使用。"></a>await()方法：一般情况下是结合promise对象使用。</h4><ul>
<li><p>只能在async函数中使用；</p>
</li>
<li><p>函数外面访问不到await及后面的表达式，如果需要在函数外部获取就需要在await前面加return。</p>
</li>
<li><p>await后面如果接的是promise对象，它拿到的是promise成功状态下的值(不需要再使用then），如果接的是其他类型就直接返回。 </p>
<ul>
<li><p><code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
</li>
<li><p>必须等待内部所有<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，才会执行<code>then</code>方法指定的回调函数</p>
</li>
<li><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(err);&#125;)  <span class="comment">//出错了</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(er) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>async函数内部代码时同步执行的，执行时如果碰到await，就会先返回；等待await后面的表达式出结果之后再继续执行函数体内后面的语句，但是await不会阻塞async函数外的代码，await等待过程中函数外的代码正常向下同步执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">&quot;promise&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 开始&quot;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn().next(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;async 结束&quot;</span>)</span><br><span class="line"><span class="comment">//async 开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//async 结束</span></span><br><span class="line"><span class="comment">//（两秒后）promise</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-3-实例-解决回调地狱-按顺序完成异步操作"><a href="#12-3-实例-解决回调地狱-按顺序完成异步操作" class="headerlink" title="12.3 实例: 解决回调地狱(按顺序完成异步操作)"></a>12.3 实例: 解决回调地狱(按顺序完成异步操作)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    type = <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    url,</span></span></span><br><span class="line"><span class="params"><span class="function">    data = &#123;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type,</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">                resolve(response)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res1 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://106.13.114.114:5000/api/firstCategory&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> firstId = res1.list[<span class="number">0</span>][<span class="number">2</span>].firstId;</span><br><span class="line">    <span class="keyword">let</span> res2 = <span class="keyword">await</span> http(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://106.13.114.114:5000/api/secondCategory&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            firstId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>



<h2 id="13、class类"><a href="#13、class类" class="headerlink" title="13、class类"></a>13、class类</h2><h3 id="13-1-概念和语法"><a href="#13-1-概念和语法" class="headerlink" title="13.1 概念和语法"></a>13.1 概念和语法</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>类和对象：</p>
<p>类：对象的类型模板，确定对象中共有的属性和行为</p>
<p>对象：类创建的实例，具体的某一个事物，一切皆为对象</p>
</li>
<li><p>ES6引入了Class(类)这个概念，通过<code>class</code>关键字，可以定义类</p>
</li>
<li><p>一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法</p>
</li>
</ul>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="#### 语法"></a>#### 语法</h4><ul>
<li><p>class关键字</p>
<ul>
<li>构造函数本身方法或者是属性要写在constructor方法里面</li>
<li>原型上的方法或者是属性直接写在class里面即可</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;<span class="comment">//定义类的构造函数</span></span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一般的方法</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭饭&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> P = <span class="keyword">new</span> Person(<span class="string">&#x27;xx&#x27;</span>,<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line">p.eat()</span><br></pre></td></tr></table></figure></li>
<li><p>constructor方法</p>
<ul>
<li>是类的默认方法，通过new命令生成对象实例时，自动调用该方法</li>
<li>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</li>
<li>默认返回实例对象(即this)</li>
</ul>
</li>
<li><p>事实上，类的所有方法都定义在类的prototype属性上面。</p>
</li>
<li><p>取值函数（getter）和存值函数（setter）（了解）</p>
<p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-2-静态方法"><a href="#13-2-静态方法" class="headerlink" title="13.2 静态方法"></a>13.2 静态方法</h3><ul>
<li><p>实例化方法和属性：（成员）</p>
<p>类相当于实例的原型(实例化对象的__proto__指向类的prototype原型)，所有在类中定义的方法，都会被实例继承</p>
<pre><code>    必须**通过实例化对象进行调用**
</code></pre>
</li>
<li><p>静态方法和静态属性：</p>
<p>在方法和属性前面加关键字static，表示该方法不会被实例继承，直接<strong>通过类进行调用</strong></p>
<p>对于一些通用性的属性或方法，可以考虑设置为静态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>：如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br><span class="line"><span class="comment">//静态方法bar调用了this.baz,  这里的this指的是Foo类，而不是Foo的实例；等同于调用Foo.baz</span></span><br><span class="line"><span class="comment">//静态方法可以与非静态方法重名</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-3-继承"><a href="#13-3-继承" class="headerlink" title="13.3 继承"></a>13.3 继承</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p><code>extends</code> 关键字</p>
</li>
<li><p>子类里，如果不写constructor是可以，默认可以添加，但是如果写入constructor函数就必须要加入super();super调用父类的constructor；super必须写constructor的第一行；</p>
</li>
<li><p>不但可以继承实例化的方法和属性，静态的方法和属性也是可以继承；</p>
</li>
<li><p><code>super</code></p>
<p>  一种是方法，一种是对象;</p>
<ul>
<li>作为方法是调用父类的constructor；</li>
<li>作为对象来说，就是在子类的方法里面调用父类的方法；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Parent</span> </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Me</span>  <span class="keyword">extends</span>  <span class="title">Parent</span>  </span>&#123;            </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>  &#123;                </span><br><span class="line">        <span class="built_in">super</span>();                </span><br><span class="line">        <span class="built_in">this</span>.x  = <span class="number">2</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>  &#123;   </span><br><span class="line">        <span class="built_in">super</span>.print();<span class="comment">//在子类的方法里调用父类的方法            </span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  b  =  <span class="keyword">new</span>  Me();        </span><br><span class="line">b.m()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
<li><p>父类的静态方法，可以被子类继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拓展-类的prototype属性和-proto-属性"><a href="#拓展-类的prototype属性和-proto-属性" class="headerlink" title="拓展:类的prototype属性和__proto__属性"></a>拓展:类的prototype属性和<code>__proto__</code>属性</h4><ul>
<li><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<ul>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true  //作为一个对象，子类(B)的原型(__proto__属性)是父类(A)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype) <span class="comment">//A &#123;constructor: ƒ&#125;</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true  //作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</span></span><br></pre></td></tr></table></figure></li>
<li><p>实例的<code>__proto__</code>属性</p>
<p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name,age,sex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age) <span class="comment">// 调用父类的constructor</span></span><br><span class="line">        <span class="built_in">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Parent(<span class="string">&quot;rose&quot;</span>,<span class="number">40</span>)</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Me(<span class="string">&quot;joth&quot;</span>,<span class="number">18</span>,<span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__);<span class="comment">//Parent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__ === Me.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__.__proto__ === p.__proto__); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2020/07/20/ES6%E7%9A%84class%E7%89%B9%E6%80%A7/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ES6-class特性</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/20/ES6的class特性/" title="ES6-class特性"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-20</div><div class="title">ES6-class特性</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Shaw</div><div class="author-info__description">sm_</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xiaoxing968"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81let%E3%80%81const%E5%92%8Cvar%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">1、let、const和var的作用和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-var"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-let"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-const"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8B%93%E5%B1%95"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">2、变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 数组解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.2.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 对象解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.3.3.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%8B%93%E5%B1%95-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 拓展 函数参数的解构赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">3、模板字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.0.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.0.2.</span> <span class="toc-text">优点:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">4.</span> <span class="toc-text">4、对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 对象的简写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-number">4.1.1.</span> <span class="toc-text">对象属性的简写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-number">4.1.2.</span> <span class="toc-text">对象方法的简写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">对象表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 对象的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 对象属性的设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%87%BD%E6%95%B0%E6%8B%93%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">5、函数拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 函数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-rest%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 rest剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 箭头函数*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.3.</span> <span class="toc-text">不适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 严格模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E7%BB%84%E6%8B%93%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">6、数组拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%A6"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 拓展运算符…</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%A6"><span class="toc-number">6.1.1.</span> <span class="toc-text">…</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BF%90%E7%94%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">数组运用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%90%E7%94%A8"><span class="toc-number">6.1.3.</span> <span class="toc-text">对象运用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 数组方法的扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Symbol%EF%BC%88%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">7、Symbol（）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 概念和作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E6%B6%88%E9%99%A4%E9%AD%94%E6%9C%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">7.1.1.</span> <span class="toc-text">实例: 消除魔术字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Symbol%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 Symbol的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#s-description"><span class="toc-number">7.2.1.</span> <span class="toc-text">s.description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-for"><span class="toc-number">7.2.2.</span> <span class="toc-text">Symbol.for()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol-keyFor"><span class="toc-number">7.2.3.</span> <span class="toc-text">Symbol.keyFor()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8B%93%E5%B1%95-%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 拓展 属性名的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81set%E5%92%8Cmap"><span class="toc-number">8.</span> <span class="toc-text">8、set和map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-number">8.0.1.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-number">8.0.2.</span> <span class="toc-text">map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81promise"><span class="toc-number">9.</span> <span class="toc-text">9、promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-promise%E6%A6%82%E5%BF%B5%EF%BC%8Cthen%E3%80%81catch%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 promise概念，then、catch方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Promise%E7%89%B9%E7%82%B9"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 Promise特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-promise%E7%9A%84%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 promise的链式操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Promise-all-%E5%92%8CPromise-race"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 Promise.all()和Promise.race()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81iterator%E5%92%8Cfor%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.</span> <span class="toc-text">10、iterator和for…of循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 概念和作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E9%83%A8%E7%BD%B2Iterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 部署Iterator接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-for%E2%80%A6in-%E5%92%8C-for%E2%80%A6of%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 for…in 和 for…of循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6of"><span class="toc-number">10.3.1.</span> <span class="toc-text">for…of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6of-%E5%92%8C-for%E2%80%A6in%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.2.</span> <span class="toc-text">for…of  和  for…in的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81generator"><span class="toc-number">11.</span> <span class="toc-text">11、generator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 概念和语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">11.1.2.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Yield%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 Yield表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-next%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">11.3 next方法的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81async%E5%87%BD%E6%95%B0-async%E2%80%A6await"><span class="toc-number">12.</span> <span class="toc-text">12、async函数  async…await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#await-%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E6%98%AF%E7%BB%93%E5%90%88promise%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">12.2.1.</span> <span class="toc-text">await()方法：一般情况下是结合promise对象使用。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%AE%9E%E4%BE%8B-%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 实例: 解决回调地狱(按顺序完成异步操作)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81class%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">13、class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 概念和语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">13.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">13.1.2.</span> <span class="toc-text">#### 语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E7%BB%A7%E6%89%BF"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">13.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-%E7%B1%BB%E7%9A%84prototype%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.2.</span> <span class="toc-text">拓展:类的prototype属性和__proto__属性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/05/16/mCustomScrollbar%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/" title="jQuery-mCustomScrollbar自定义滚动条"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery-mCustomScrollbar自定义滚动条"/></a><div class="content"><a class="title" href="/2021/05/16/mCustomScrollbar%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1/" title="jQuery-mCustomScrollbar自定义滚动条">jQuery-mCustomScrollbar自定义滚动条</a><time datetime="2021-05-15T16:00:00.000Z" title="发表于 2021-05-16 00:00:00">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/15/jQuery-select2/" title="jQuery-select2可远程下拉框"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jQuery-select2可远程下拉框"/></a><div class="content"><a class="title" href="/2021/05/15/jQuery-select2/" title="jQuery-select2可远程下拉框">jQuery-select2可远程下拉框</a><time datetime="2021-05-14T16:00:00.000Z" title="发表于 2021-05-15 00:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/25/node%E7%AC%94%E8%AE%B0/" title="Node.js"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.js"/></a><div class="content"><a class="title" href="/2020/10/25/node%E7%AC%94%E8%AE%B0/" title="Node.js">Node.js</a><time datetime="2020-10-24T16:00:00.000Z" title="发表于 2020-10-25 00:00:00">2020-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/20/ES6%E7%9A%84class%E7%89%B9%E6%80%A7/" title="ES6-class特性"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6-class特性"/></a><div class="content"><a class="title" href="/2020/07/20/ES6%E7%9A%84class%E7%89%B9%E6%80%A7/" title="ES6-class特性">ES6-class特性</a><time datetime="2020-07-19T16:00:00.000Z" title="发表于 2020-07-20 00:00:00">2020-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/16/ES6-%E7%AC%94%E8%AE%B0/" title="ES6-笔记"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6-笔记"/></a><div class="content"><a class="title" href="/2020/06/16/ES6-%E7%AC%94%E8%AE%B0/" title="ES6-笔记">ES6-笔记</a><time datetime="2020-06-15T16:00:00.000Z" title="发表于 2020-06-16 00:00:00">2020-06-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div></div></body></html>